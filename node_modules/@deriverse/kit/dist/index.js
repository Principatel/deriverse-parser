"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Engine = exports.getPerpPriceStep = exports.getSpotPriceStep = void 0;
const kit_1 = require("@solana/kit");
const system_1 = require("@solana-program/system");
const bs58_1 = require("bs58");
const buffer_1 = require("buffer");
const types_1 = require("./types");
const structure_models_1 = require("./structure_models");
const instruction_models_1 = require("./instruction_models");
const base64_arraybuffer_1 = require("base64-arraybuffer");
const logs_models_1 = require("./logs_models");
__exportStar(require("./types"), exports);
__exportStar(require("./logs_models"), exports);
const ADDRESS_LOOKUP_TABLE_PROGRAM_ID = (0, kit_1.address)("AddressLookupTab1e1111111111111111111111111");
const SYSTEM_PROGRAM_ID = (0, kit_1.address)("11111111111111111111111111111111");
const TOKEN_PROGRAM_ID = (0, kit_1.address)('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
const TOKEN_2022_PROGRAM_ID = (0, kit_1.address)('TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb');
const ASSOCIATED_TOKEN_PROGRAM_ID = (0, kit_1.address)('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
let dec = 1000000000;
let lpDec = 10000;
const nullOrder = 0xFFFF;
/**
 * Get price step between orderbook lines depending on curent price
 * @param price Current market price
 * @returns Price step
 */
function getSpotPriceStep(price) {
    if (price <= 0.00001) {
        return 0.000000001;
    }
    else if (price <= 0.00002) {
        return 0.000000002;
    }
    else if (price <= 0.00005) {
        return 0.000000005;
    }
    else if (price <= 0.0001) {
        return 0.00000001;
    }
    else if (price <= 0.0002) {
        return 0.00000002;
    }
    else if (price <= 0.0005) {
        return 0.00000005;
    }
    else if (price <= 0.001) {
        return 0.0000001;
    }
    else if (price <= 0.002) {
        return 0.0000002;
    }
    else if (price <= 0.005) {
        return 0.0000005;
    }
    else if (price <= 0.01) {
        return 0.000001;
    }
    else if (price <= 0.02) {
        return 0.000002;
    }
    else if (price <= 0.05) {
        return 0.000005;
    }
    else if (price <= 0.1) {
        return 0.00001;
    }
    else if (price <= 0.2) {
        return 0.00002;
    }
    else if (price <= 0.5) {
        return 0.00005;
    }
    else if (price <= 1) {
        return 0.0001;
    }
    else if (price <= 2) {
        return 0.0002;
    }
    else if (price <= 5) {
        return 0.0005;
    }
    else if (price <= 10) {
        return 0.001;
    }
    else if (price <= 20) {
        return 0.002;
    }
    else if (price <= 50) {
        return 0.005;
    }
    else if (price <= 100) {
        return 0.01;
    }
    else if (price <= 200) {
        return 0.02;
    }
    else if (price <= 500) {
        return 0.05;
    }
    else if (price <= 1000) {
        return 0.1;
    }
    else if (price <= 2000) {
        return 0.2;
    }
    else if (price <= 5000) {
        return 0.5;
    }
    else if (price <= 10000) {
        return 1;
    }
    else if (price <= 20000) {
        return 2;
    }
    else if (price <= 50000) {
        return 5;
    }
    else if (price <= 100000) {
        return 10;
    }
    else if (price <= 200000) {
        return 20;
    }
    else if (price <= 500000) {
        return 50;
    }
    else if (price <= 1000000) {
        return 100;
    }
    else if (price <= 2000000) {
        return 200;
    }
    else if (price <= 5000000) {
        return 500;
    }
    else {
        return 1000;
    }
}
exports.getSpotPriceStep = getSpotPriceStep;
/**
 * Get price step between orderbook lines depending on curent price
 * @param price Current market price
 * @returns Price step
 */
function getPerpPriceStep(price) {
    if (price <= 0.00005) {
        return 0.000000001;
    }
    else if (price <= 0.0001) {
        return 0.000000002;
    }
    else if (price <= 0.0002) {
        return 0.000000005;
    }
    else if (price <= 0.0005) {
        return 0.00000001;
    }
    else if (price <= 0.001) {
        return 0.00000002;
    }
    else if (price <= 0.002) {
        return 0.00000005;
    }
    else if (price <= 0.005) {
        return 0.0000001;
    }
    else if (price <= 0.01) {
        return 0.0000002;
    }
    else if (price <= 0.02) {
        return 0.0000005;
    }
    else if (price <= 0.05) {
        return 0.000001;
    }
    else if (price <= 0.1) {
        return 0.000002;
    }
    else if (price <= 0.2) {
        return 0.000005;
    }
    else if (price <= 0.5) {
        return 0.00001;
    }
    else if (price <= 1) {
        return 0.00002;
    }
    else if (price <= 2) {
        return 0.00005;
    }
    else if (price <= 5) {
        return 0.0001;
    }
    else if (price <= 10) {
        return 0.0002;
    }
    else if (price <= 20) {
        return 0.0005;
    }
    else if (price <= 50) {
        return 0.001;
    }
    else if (price <= 100) {
        return 0.002;
    }
    else if (price <= 200) {
        return 0.005;
    }
    else if (price <= 500) {
        return 0.01;
    }
    else if (price <= 1000) {
        return 0.02;
    }
    else if (price <= 2000) {
        return 0.05;
    }
    else if (price <= 5000) {
        return 0.1;
    }
    else if (price <= 10000) {
        return 0.2;
    }
    else if (price <= 20000) {
        return 0.5;
    }
    else if (price <= 50000) {
        return 1;
    }
    else if (price <= 100000) {
        return 2;
    }
    else if (price <= 200000) {
        return 5;
    }
    else if (price <= 500000) {
        return 10;
    }
    else if (price <= 1000000) {
        return 20;
    }
    else if (price <= 2000000) {
        return 50;
    }
    else if (price <= 5000000) {
        return 100;
    }
    else if (price <= 10000000) {
        return 200;
    }
    else if (price <= 20000000) {
        return 500;
    }
    else {
        return 1000;
    }
}
exports.getPerpPriceStep = getPerpPriceStep;
function perpSeatReserve(activeUsers) {
    return 250000 * activeUsers / (25000 - activeUsers);
}
function findAssociatedTokenAddress(owner, tokenProgramId, mint) {
    return __awaiter(this, void 0, void 0, function* () {
        const address = (yield (0, kit_1.getProgramDerivedAddress)({
            programAddress: ASSOCIATED_TOKEN_PROGRAM_ID,
            seeds: [
                (0, kit_1.getAddressEncoder)().encode(owner),
                (0, kit_1.getAddressEncoder)().encode(tokenProgramId),
                (0, kit_1.getAddressEncoder)().encode(mint),
            ]
        }))[0];
        return address;
    });
}
function getMultipleSpotOrders(data, firstEntry, clientId) {
    let orders = [];
    let entry = firstEntry;
    while (entry != nullOrder) {
        const offset = entry * 64 + structure_models_1.SpotTradeAccountHeaderModel.LENGTH;
        const order = structure_models_1.OrderModel.fromBuffer(data, offset);
        if (order.origClientId != clientId) {
            break;
        }
        orders.push(order);
        entry = order.clNext;
    }
    return orders;
}
function getMultiplePerpOrders(data, firstEntry, clientId) {
    let orders = [];
    let entry = firstEntry;
    while (entry != nullOrder) {
        const offset = entry * 64 + structure_models_1.PerpTradeAccountHeaderModel.LENGTH;
        const order = structure_models_1.OrderModel.fromBuffer(data, offset);
        if (order.origClientId != clientId) {
            break;
        }
        orders.push(order);
        entry = order.clNext;
    }
    return orders;
}
function getLookupTableAddress(authority, slot) {
    return __awaiter(this, void 0, void 0, function* () {
        let buf = buffer_1.Buffer.alloc(8);
        buf.writeBigInt64LE(BigInt(slot), 0);
        const address = (yield (0, kit_1.getProgramDerivedAddress)({
            programAddress: ADDRESS_LOOKUP_TABLE_PROGRAM_ID,
            seeds: [(0, kit_1.getAddressEncoder)().encode(authority), buf]
        }))[0];
        return address;
    });
}
/**
 * Main class to operate with Deriverse
 * @property {number} originalClientId Deriverse main client ID
 * @property {AddressLookupTableAccount} lut Root address lookup table account
 * @property {AddressLookupTableAccount} clientLut Client address lookup table account
 * @property {Map<number, Token>} tokens Tokens data
 * @property {Map<number, Instrument>} instruments Instruments data
 */
class Engine {
    /**
     * @param rpc @solana/kit rpc
     */
    constructor(rpc, args) {
        this.rpc = rpc;
        if (args == undefined || args.programId == null || args.programId == undefined) {
            this.programId = types_1.PROGRAM_ID;
        }
        else {
            this.programId = args.programId;
        }
        if (args == undefined || args.version == null || args.version == undefined) {
            this.version = types_1.VERSION;
        }
        else {
            this.version = args.version;
        }
        if (args == undefined || args.commitment == null || args.commitment == undefined) {
            this.commitment = 'confirmed';
        }
        else {
            this.commitment = args.commitment;
        }
        if (args == undefined || args.uiNumbers == null || args.uiNumbers == undefined) {
            this.uiNumbers = true;
        }
        else {
            this.uiNumbers = args.uiNumbers;
        }
        if (!this.uiNumbers) {
            dec = 1;
            lpDec = 1;
        }
    }
    logsDecode(data) {
        let assetTokenDec = 1;
        let crncyTokenDec = 1;
        let logs = [];
        for (var log of data) {
            if (log.startsWith("Program returned error") || log.startsWith(`Program logged: "Error`)) {
                return [];
            }
            if (!log.startsWith("Program data: ")) {
                continue;
            }
            const buffer = buffer_1.Buffer.from((0, base64_arraybuffer_1.decode)(log.substring(14)));
            switch (buffer[0]) {
                case logs_models_1.LogType.deposit: {
                    if (buffer.length == logs_models_1.DepositReportModel.LENGTH) {
                        let report = logs_models_1.DepositReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            crncyTokenDec = this.tokenDec(report.tokenId);
                            report.amount /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.withdraw: {
                    if (buffer.length == logs_models_1.WithdrawReportModel.LENGTH) {
                        let report = logs_models_1.WithdrawReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            crncyTokenDec = this.tokenDec(report.tokenId);
                            report.amount /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.perpDeposit: {
                    if (buffer.length == logs_models_1.PerpDepositReportModel.LENGTH) {
                        let report = logs_models_1.PerpDepositReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            const instrInfo = this.instruments.get(report.instrId);
                            if (instrInfo) {
                                crncyTokenDec = this.tokenDec(instrInfo.header.crncyTokenId);
                                report.amount /= crncyTokenDec;
                            }
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.buyMarketSeat: {
                    if (buffer.length == logs_models_1.BuyMarketSeatReportModel.LENGTH) {
                        let report = logs_models_1.BuyMarketSeatReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            const instrInfo = this.instruments.get(report.instrId);
                            if (instrInfo) {
                                crncyTokenDec = this.tokenDec(instrInfo.header.crncyTokenId);
                                report.amount /= crncyTokenDec;
                                report.seatPrice /= crncyTokenDec;
                            }
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.sellMarketSeat: {
                    if (buffer.length == logs_models_1.SellMarketSeatReportModel.LENGTH) {
                        let report = logs_models_1.SellMarketSeatReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            const instrInfo = this.instruments.get(report.instrId);
                            if (instrInfo) {
                                crncyTokenDec = this.tokenDec(instrInfo.header.crncyTokenId);
                                report.seatPrice /= crncyTokenDec;
                            }
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.perpWithdraw: {
                    if (buffer.length == logs_models_1.PerpWithdrawReportModel.LENGTH) {
                        let report = logs_models_1.PerpWithdrawReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            const instrInfo = this.instruments.get(report.instrId);
                            if (instrInfo) {
                                crncyTokenDec = this.tokenDec(instrInfo.header.crncyTokenId);
                                report.amount /= crncyTokenDec;
                            }
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.feesDeposit: {
                    if (buffer.length == logs_models_1.FeesDepositReportModel.LENGTH) {
                        let report = logs_models_1.FeesDepositReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            crncyTokenDec = this.tokenDec(report.tokenId);
                            report.amount /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.feesWithdraw: {
                    if (buffer.length == logs_models_1.FeesWithdrawReportModel.LENGTH) {
                        let report = logs_models_1.FeesWithdrawReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            crncyTokenDec = this.tokenDec(report.tokenId);
                            report.amount /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.spotLpTrade: {
                    if (buffer.length == logs_models_1.SpotlpTradeReportModel.LENGTH) {
                        let report = logs_models_1.SpotlpTradeReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            const instrInfo = this.instruments.get(report.instrId);
                            if (instrInfo) {
                                assetTokenDec = this.tokenDec(instrInfo.header.assetTokenId);
                                crncyTokenDec = this.tokenDec(instrInfo.header.crncyTokenId);
                                report.qty /= lpDec;
                                report.tokens /= assetTokenDec;
                                report.crncy /= crncyTokenDec;
                            }
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.moveSpot: {
                    if (buffer.length == logs_models_1.MoveSpotAvailFundsReportModel.LENGTH) {
                        let report = logs_models_1.MoveSpotAvailFundsReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            const instrInfo = this.instruments.get(report.instrId);
                            if (instrInfo) {
                                assetTokenDec = this.tokenDec(instrInfo.header.assetTokenId);
                                crncyTokenDec = this.tokenDec(instrInfo.header.crncyTokenId);
                                report.qty /= assetTokenDec;
                                report.crncy /= crncyTokenDec;
                            }
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.earnings: {
                    if (buffer.length == logs_models_1.EarningsReportModel.LENGTH) {
                        let report = logs_models_1.EarningsReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            crncyTokenDec = this.tokenDec(report.tokenId);
                            report.amount /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.drvsAirdrop: {
                    if (buffer.length == logs_models_1.DrvsAirdropReportModel.LENGTH) {
                        let report = logs_models_1.DrvsAirdropReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            crncyTokenDec = this.tokenDec(0);
                            report.amount /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.spotPlaceOrder: {
                    if (buffer.length == logs_models_1.SpotPlaceOrderReportModel.LENGTH) {
                        let report = logs_models_1.SpotPlaceOrderReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            const instrInfo = this.instruments.get(report.instrId);
                            if (instrInfo) {
                                assetTokenDec = this.tokenDec(instrInfo.header.assetTokenId);
                                crncyTokenDec = this.tokenDec(instrInfo.header.crncyTokenId);
                                report.qty /= assetTokenDec;
                            }
                            report.price /= dec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.spotFillOrder: {
                    if (buffer.length == logs_models_1.SpotFillOrderReportModel.LENGTH) {
                        let report = logs_models_1.SpotFillOrderReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            report.qty /= assetTokenDec;
                            report.crncy /= crncyTokenDec;
                            report.rebates /= crncyTokenDec;
                            report.price /= dec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.spotNewOrder: {
                    if (buffer.length == logs_models_1.SpotNewOrderReportModel.LENGTH) {
                        let report = logs_models_1.SpotNewOrderReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            report.qty /= assetTokenDec;
                            report.crncy /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.spotOrderCancel: {
                    if (buffer.length == logs_models_1.SpotOrderCancelReportModel.LENGTH) {
                        let report = logs_models_1.SpotOrderCancelReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            const instrInfo = this.instruments.get(report.instrId);
                            if (instrInfo) {
                                assetTokenDec = this.tokenDec(instrInfo.header.assetTokenId);
                                crncyTokenDec = this.tokenDec(instrInfo.header.crncyTokenId);
                                report.qty /= assetTokenDec;
                                report.crncy /= crncyTokenDec;
                            }
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.spotOrderRevoke: {
                    if (buffer.length == logs_models_1.SpotOrderRevokeReportModel.LENGTH) {
                        let report = logs_models_1.SpotOrderRevokeReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            report.qty /= assetTokenDec;
                            report.crncy /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.spotFees: {
                    if (buffer.length == logs_models_1.SpotFeesReportModel.LENGTH) {
                        let report = logs_models_1.SpotFeesReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            report.fees /= crncyTokenDec;
                            report.refPayment /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.spotPlaceMassCancel: {
                    if (buffer.length == logs_models_1.SpotPlaceMassCancelReportModel.LENGTH) {
                        let report = logs_models_1.SpotPlaceMassCancelReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            const instrInfo = this.instruments.get(report.instrId);
                            if (instrInfo) {
                                assetTokenDec = this.tokenDec(instrInfo.header.assetTokenId);
                                crncyTokenDec = this.tokenDec(instrInfo.header.crncyTokenId);
                            }
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.spotMassCancel: {
                    if (buffer.length == logs_models_1.SpotMassCancelReportModel.LENGTH) {
                        let report = logs_models_1.SpotMassCancelReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            report.qty /= assetTokenDec;
                            report.crncy /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.perpPlaceOrder: {
                    if (buffer.length == logs_models_1.PerpPlaceOrderReportModel.LENGTH) {
                        let report = logs_models_1.PerpPlaceOrderReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            const instrInfo = this.instruments.get(report.instrId);
                            if (instrInfo) {
                                assetTokenDec = this.tokenDec(instrInfo.header.assetTokenId);
                                crncyTokenDec = this.tokenDec(instrInfo.header.crncyTokenId);
                                report.perps /= assetTokenDec;
                            }
                            report.price /= dec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.perpFillOrder: {
                    if (buffer.length == logs_models_1.PerpFillOrderReportModel.LENGTH) {
                        let report = logs_models_1.PerpFillOrderReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            report.perps /= assetTokenDec;
                            report.crncy /= crncyTokenDec;
                            report.rebates /= crncyTokenDec;
                            report.price /= dec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.perpNewOrder: {
                    if (buffer.length == logs_models_1.PerpNewOrderReportModel.LENGTH) {
                        let report = logs_models_1.PerpNewOrderReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            report.perps /= assetTokenDec;
                            report.crncy /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.perpOrderCancel: {
                    if (buffer.length == logs_models_1.PerpOrderCancelReportModel.LENGTH) {
                        let report = logs_models_1.PerpOrderCancelReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            const instrInfo = this.instruments.get(report.instrId);
                            if (instrInfo) {
                                assetTokenDec = this.tokenDec(instrInfo.header.assetTokenId);
                                crncyTokenDec = this.tokenDec(instrInfo.header.crncyTokenId);
                                report.perps /= assetTokenDec;
                                report.crncy /= crncyTokenDec;
                            }
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.perpOrderRevoke: {
                    if (buffer.length == logs_models_1.PerpOrderRevokeReportModel.LENGTH) {
                        let report = logs_models_1.PerpOrderRevokeReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            report.perps /= assetTokenDec;
                            report.crncy /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.perpFees: {
                    if (buffer.length == logs_models_1.PerpFeesReportModel.LENGTH) {
                        let report = logs_models_1.PerpFeesReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            report.fees /= crncyTokenDec;
                            report.refPayment /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.perpPlaceMassCancel: {
                    if (buffer.length == logs_models_1.PerpPlaceMassCancelReportModel.LENGTH) {
                        let report = logs_models_1.PerpPlaceMassCancelReportModel.fromBuffer(buffer);
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.perpMassCancel: {
                    if (buffer.length == logs_models_1.PerpMassCancelReportModel.LENGTH) {
                        let report = logs_models_1.PerpMassCancelReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            report.perps /= assetTokenDec;
                            report.crncy /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.perpFunding: {
                    if (buffer.length == logs_models_1.PerpFundingReportModel.LENGTH) {
                        let report = logs_models_1.PerpFundingReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            report.funding /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.perpSocLoss: {
                    if (buffer.length == logs_models_1.PerpSocLossReportModel.LENGTH) {
                        let report = logs_models_1.PerpSocLossReportModel.fromBuffer(buffer);
                        if (this.uiNumbers) {
                            report.socLoss /= crncyTokenDec;
                        }
                        logs.push(report);
                    }
                    break;
                }
                case logs_models_1.LogType.perpChangeLeverage: {
                    if (buffer.length == logs_models_1.PerpChangeLeverageReportModel.LENGTH) {
                        let report = logs_models_1.PerpChangeLeverageReportModel.fromBuffer(buffer);
                        logs.push(report);
                    }
                    break;
                }
            }
        }
        return logs;
    }
    findAccountsByTag(tag, dataSlice) {
        return __awaiter(this, void 0, void 0, function* () {
            let tagBuf = buffer_1.Buffer.alloc(8);
            tagBuf.writeUInt32LE(tag, 0);
            tagBuf.writeUInt32LE(this.version, 4);
            let accounts = yield this.rpc.getProgramAccounts(this.programId, {
                encoding: 'base64',
                dataSlice: dataSlice,
                filters: [
                    {
                        memcmp: {
                            offset: BigInt(0),
                            encoding: 'base58',
                            bytes: (0, bs58_1.encode)(tagBuf),
                        },
                    },
                ],
            }).send();
            return accounts;
        });
    }
    /**
     * After creation you have to initialize Engine
     */
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.drvsAuthority = (yield (0, kit_1.getProgramDerivedAddress)({ programAddress: this.programId, seeds: ["ndxnt"] }))[0];
                this.rootAccount = yield this.getAccountByTag(types_1.AccountType.ROOT);
                this.communityAccount = yield this.getAccountByTag(types_1.AccountType.COMMUNITY);
                const infos = yield this.rpc.getMultipleAccounts([this.rootAccount, this.communityAccount], {
                    commitment: this.commitment,
                    encoding: 'base64'
                }).send();
                if (infos.value == null) {
                    throw new Error("Initialization failed: getMultipleAccountsInfo");
                }
                this.rootStateModel = structure_models_1.RootStateModel.fromBuffer(infos.value[0].data);
                this.tokens = new Map();
                this.instruments = new Map();
                this.privateMode = (this.rootStateModel.mask & 1) != 0;
                const tokenAccounts = yield this.findAccountsByTag(types_1.AccountType.TOKEN);
                tokenAccounts.forEach((t) => {
                    let tokenStateModel = structure_models_1.TokenStateModel.fromBuffer(t.account.data);
                    this.tokens.set(tokenStateModel.id, tokenStateModel);
                });
                const instrAccounts = yield this.findAccountsByTag(types_1.AccountType.INSTR, { offset: 8, length: 16 });
                instrAccounts.forEach((response) => {
                    const buffer = buffer_1.Buffer.from((0, kit_1.getBase64Encoder)().encode(response.account.data[0]));
                    let instrAccountHeaderModel = new structure_models_1.InstrAccountHeaderModel();
                    instrAccountHeaderModel.instrId = buffer.readUint32LE(0);
                    instrAccountHeaderModel.assetTokenId = buffer.readUint32LE(4);
                    instrAccountHeaderModel.crncyTokenId = buffer.readUint32LE(8);
                    instrAccountHeaderModel.mask = buffer.readUint32LE(12);
                    this.instruments.set(instrAccountHeaderModel.instrId, {
                        address: response.pubkey,
                        header: instrAccountHeaderModel,
                        spotBids: [],
                        spotAsks: [],
                        perpBids: [],
                        perpAsks: [],
                    });
                });
                this.updateCommunityFromBuffer(infos.value[1].data);
                return true;
            }
            catch (err) {
                console.log("Initialization failed:", err);
                return false;
            }
        });
    }
    addToken(tokenAccount) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield this.rpc.getAccountInfo(tokenAccount, { commitment: this.commitment, encoding: 'base64' }).send();
            if (info.value == null) {
                throw new Error("Add Token Failed: getAccountInfo");
            }
            const tokenStateModel = structure_models_1.TokenStateModel.fromBuffer(info.value.data);
            if (tokenStateModel.id > this.rootStateModel.tokensCount ||
                tokenStateModel.tag != types_1.AccountType.TOKEN ||
                tokenStateModel.version != this.version) {
                throw new Error("Invalid Token Account");
            }
            this.tokens.set(tokenStateModel.id, tokenStateModel);
        });
    }
    addInstr(instrAccount) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield this.rpc.getAccountInfo(instrAccount, { commitment: this.commitment, encoding: 'base64' }).send();
            if (info.value == null) {
                throw new Error("Add Instrument Failed: getAccountInfo");
            }
            const instrAccountHeaderModel = structure_models_1.InstrAccountHeaderModel.fromBuffer(info.value.data);
            if (instrAccountHeaderModel.instrId > this.rootStateModel.instrCount ||
                instrAccountHeaderModel.tag != types_1.AccountType.INSTR ||
                instrAccountHeaderModel.version != this.version) {
                throw new Error("Invalid Instrument Account");
            }
            this.instruments.set(instrAccountHeaderModel.instrId, {
                address: instrAccount,
                header: instrAccountHeaderModel,
                spotBids: [],
                spotAsks: [],
                perpBids: [],
                perpAsks: [],
            });
        });
    }
    updateCommunityFromBuffer(data) {
        let baseCrncyRecords = new Map();
        let communityAccountHeaderModel = structure_models_1.CommunityAccountHeaderModel.fromBuffer(data);
        const drvsDec = this.tokenDec(0);
        communityAccountHeaderModel.prevVotingSupply /= drvsDec;
        communityAccountHeaderModel.votingSupply /= drvsDec;
        communityAccountHeaderModel.drvsTokens /= drvsDec;
        for (var i = 0; i < communityAccountHeaderModel.count; ++i) {
            let record = structure_models_1.BaseCrncyRecordModel.fromBuffer(data, structure_models_1.CommunityAccountHeaderModel.LENGTH + i * structure_models_1.BaseCrncyRecordModel.LENGTH);
            record.funds /= this.tokenDec(record.crncyTokenId);
            baseCrncyRecords.set(record.crncyTokenId, record);
        }
        this.community = {
            header: communityAccountHeaderModel,
            data: baseCrncyRecords
        };
    }
    updateCommunity() {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield this.rpc.getAccountInfo(this.communityAccount, { commitment: this.commitment, encoding: 'base64' }).send();
            if (info.value == null) {
                throw new Error("Community Account: GetAccountInfo Failed");
            }
            this.updateCommunityFromBuffer(info.value.data);
        });
    }
    updateRootFromBuffer(data) {
        this.rootStateModel = structure_models_1.RootStateModel.fromBuffer(data);
    }
    updateRoot() {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield this.rpc.getAccountInfo(this.rootAccount, { commitment: this.commitment, encoding: 'base64' }).send();
            if (info.value == null) {
                throw new Error("Root Account: GetAccountInfo Failed");
            }
            this.updateRootFromBuffer(info.value.data);
        });
    }
    getInstrAccountByTag(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let buf = buffer_1.Buffer.alloc(16);
            buf.writeInt32LE(this.version, 0);
            buf.writeInt32LE(args.tag, 4);
            buf.writeInt32LE(args.assetTokenId, 8);
            buf.writeInt32LE(args.crncyTokenId, 12);
            const address = (yield (0, kit_1.getProgramDerivedAddress)({
                programAddress: this.programId,
                seeds: [buf, (0, kit_1.getAddressEncoder)().encode(this.drvsAuthority)]
            }))[0];
            return address;
        });
    }
    getAccountByTag(tag) {
        return __awaiter(this, void 0, void 0, function* () {
            let buf = buffer_1.Buffer.alloc(8);
            buf.writeInt32LE(this.version, 0);
            buf.writeInt32LE(tag, 4);
            const address = (yield (0, kit_1.getProgramDerivedAddress)({
                programAddress: this.programId,
                seeds: [buf, (0, kit_1.getAddressEncoder)().encode(this.drvsAuthority)]
            }))[0];
            return address;
        });
    }
    getSpotContext(instrAccountHeaderModel) {
        return __awaiter(this, void 0, void 0, function* () {
            return [
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.INSTR
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.SPOT_BIDS_TREE
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.SPOT_ASKS_TREE
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.SPOT_BID_ORDERS
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.SPOT_ASK_ORDERS
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.SPOT_LINES
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: instrAccountHeaderModel.mapsAddress,
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.SPOT_CLIENT_INFOS
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.SPOT_CLIENT_INFOS2
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
            ];
        });
    }
    getPerpContext(instrAccountHeaderModel) {
        return __awaiter(this, void 0, void 0, function* () {
            return [
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.INSTR
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.PERP_BIDS_TREE
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.PERP_ASKS_TREE
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.PERP_BID_ORDERS
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.PERP_ASK_ORDERS
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.PERP_LINES
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: instrAccountHeaderModel.perpMapsAddress,
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.PERP_CLIENT_INFOS
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.PERP_CLIENT_INFOS2
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.PERP_CLIENT_INFOS3
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.PERP_CLIENT_INFOS4
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.PERP_CLIENT_INFOS5
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.PERP_LONG_PX_TREE
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.PERP_SHORT_PX_TREE
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.PERP_REBALANCE_TIME_TREE
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
            ];
        });
    }
    getSpotCandles(instrAccountHeaderModel) {
        return __awaiter(this, void 0, void 0, function* () {
            return [
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.SPOT_1M_CANDLES
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.SPOT_15M_CANDLES
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instrAccountHeaderModel.assetTokenId,
                        crncyTokenId: instrAccountHeaderModel.crncyTokenId,
                        tag: types_1.AccountType.SPOT_DAY_CANDLES
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
            ];
        });
    }
    getTokenAccount(mint) {
        return __awaiter(this, void 0, void 0, function* () {
            let buf = buffer_1.Buffer.from((0, kit_1.getAddressEncoder)().encode(mint).buffer);
            buf.writeInt32LE(this.version, 28);
            const address = (yield (0, kit_1.getProgramDerivedAddress)({
                programAddress: this.programId,
                seeds: [buf, (0, kit_1.getAddressEncoder)().encode(this.drvsAuthority)]
            }))[0];
            return address;
        });
    }
    /**
     * Get Token ID from mint public key if this token registered on Deriverse
     * @param mint Public key
     * @returns Token ID
     */
    getTokenId(mint) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenAddress = yield this.getTokenAccount(mint);
            let info = yield this.rpc.getAccountInfo(tokenAddress, { commitment: this.commitment, encoding: 'base64', dataSlice: { offset: structure_models_1.TokenStateModel.OFFSET_ID, length: 4 } }).send();
            if (!info.value) {
                return null;
            }
            else {
                const data = buffer_1.Buffer.from((0, kit_1.getBase64Encoder)().encode(info.value.data[0]));
                return data.readUInt32LE(0);
            }
        });
    }
    /**
     * Get intrument ID if this instrument registered on Deriverse
     * @param args Base crncy Token ID and asset token ID
     * @returns Instrument ID
     */
    getInstrId(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let buf = buffer_1.Buffer.alloc(16);
            buf.writeInt32LE(this.version, 0);
            buf.writeInt32LE(types_1.AccountType.INSTR, 4);
            buf.writeInt32LE(args.assetTokenId, 8);
            buf.writeInt32LE(args.crncyTokenId, 12);
            const instrAddress = yield this.getInstrAccountByTag({
                assetTokenId: args.assetTokenId,
                crncyTokenId: args.crncyTokenId,
                tag: types_1.AccountType.INSTR
            });
            let info = yield this.rpc.getAccountInfo(instrAddress, { commitment: this.commitment, encoding: 'base64', dataSlice: { offset: structure_models_1.InstrAccountHeaderModel.OFFSET_INSTR_ID, length: 4 } }).send();
            if (info.value == null) {
                return null;
            }
            else {
                const data = buffer_1.Buffer.from((0, kit_1.getBase64Encoder)().encode(info.value.data[0]));
                return data.readUInt32LE(0);
            }
        });
    }
    /**
     * Assignes client public key to Engine
     * @param signer Client public key
     */
    setSigner(signer) {
        return __awaiter(this, void 0, void 0, function* () {
            this.signer = signer;
            let buf = buffer_1.Buffer.alloc(8);
            buf.writeUint32LE(this.version, 0);
            buf.writeUint32LE(types_1.AccountType.CLIENT_PRIMARY, 4);
            const clientPrimaryAccount = yield this.findClientPrimaryAccount(signer);
            let exists = false;
            try {
                const info = yield this.rpc.getAccountInfo(clientPrimaryAccount, {
                    commitment: this.commitment,
                    encoding: 'base64'
                }).send();
                if (info.value) {
                    const clientPrimaryAccountHeaderModel = structure_models_1.ClientPrimaryAccountHeaderModel.fromBuffer(info.value.data);
                    if (clientPrimaryAccountHeaderModel.walletAddress == signer) {
                        this.clientPrimaryAccount = clientPrimaryAccount;
                        this.clientCommunityAccount = yield this.findClientCommunityAccount(signer);
                        this.originalClientId = clientPrimaryAccountHeaderModel.id;
                        this.clientLutAddress = clientPrimaryAccountHeaderModel.lutAddress;
                        let date = Math.floor((new Date()).valueOf() / 1000);
                        if (date < clientPrimaryAccountHeaderModel.refProgramExpiration) {
                            this.refClientPrimaryAccount = clientPrimaryAccountHeaderModel.refAddress;
                            let refInfo = yield this.rpc.getAccountInfo(this.refClientPrimaryAccount, {
                                commitment: this.commitment,
                                encoding: 'base64'
                            }).send();
                            const refClientPrimaryAccountHeaderModel = structure_models_1.ClientPrimaryAccountHeaderModel.fromBuffer(refInfo.value.data);
                            this.refClientCommunityAccount =
                                yield this.findClientCommunityAccount(refClientPrimaryAccountHeaderModel.walletAddress);
                        }
                        exists = true;
                    }
                }
            }
            catch (err) {
                console.log(err);
                throw new Error("Wallet connection failed");
            }
            if (!exists) {
                this.clientPrimaryAccount = null;
                this.originalClientId = null;
            }
        });
    }
    findClientPrimaryAccount(wallet) {
        return __awaiter(this, void 0, void 0, function* () {
            let tagBuf = buffer_1.Buffer.alloc(8);
            tagBuf.writeUint32LE(this.version, 0);
            tagBuf.writeUint32LE(types_1.AccountType.CLIENT_PRIMARY, 4);
            let source = (wallet == null || wallet == undefined) ? this.signer : wallet;
            const address = (yield (0, kit_1.getProgramDerivedAddress)({
                programAddress: this.programId,
                seeds: [tagBuf, (0, kit_1.getAddressEncoder)().encode(source)]
            }))[0];
            return address;
        });
    }
    findClientCommunityAccount(wallet) {
        return __awaiter(this, void 0, void 0, function* () {
            let tagBuf = buffer_1.Buffer.alloc(8);
            tagBuf.writeUint32LE(this.version, 0);
            tagBuf.writeUint32LE(types_1.AccountType.CLIENT_COMMUNITY, 4);
            let source = (wallet == null || wallet == undefined) ? this.signer : wallet;
            const address = (yield (0, kit_1.getProgramDerivedAddress)({
                programAddress: this.programId,
                seeds: [tagBuf, (0, kit_1.getAddressEncoder)().encode(source)]
            }))[0];
            return address;
        });
    }
    checkClient() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.signer == null) {
                throw new Error("Wallet not connected");
            }
            if (this.clientPrimaryAccount != null) {
                return true;
            }
            const clientPrimaryAccount = yield this.findClientPrimaryAccount();
            try {
                const info = yield this.rpc.getAccountInfo(clientPrimaryAccount, {
                    commitment: this.commitment,
                    encoding: 'base64'
                }).send();
                if (info.value == null) {
                    return false;
                }
                const clientPrimaryAccountHeaderModel = structure_models_1.ClientPrimaryAccountHeaderModel.fromBuffer(info.value.data);
                this.clientPrimaryAccount = clientPrimaryAccount;
                this.clientCommunityAccount = yield this.findClientCommunityAccount();
                this.originalClientId = clientPrimaryAccountHeaderModel.id;
                return true;
            }
            catch (err) {
                console.log(err);
                return false;
            }
        });
    }
    /**
     * Unpack client accounts
     * @returns All client data that are in client accounts
     */
    getClientData() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            const infos = yield this.rpc.getMultipleAccounts([this.clientPrimaryAccount, this.clientCommunityAccount], {
                commitment: this.commitment,
                encoding: 'base64'
            }).send();
            if (infos.value == null) {
                throw new Error("GetClientData: GetAccountInfo failed");
            }
            const clientPrimaryAccountHeaderModel = structure_models_1.ClientPrimaryAccountHeaderModel.fromBuffer(infos.value[0].data);
            let clientCommunityAccountHeaderModel = structure_models_1.ClientCommunityAccountHeaderModel.fromBuffer(infos.value[1].data);
            const primaryData = buffer_1.Buffer.from((0, kit_1.getBase64Encoder)().encode(infos.value[0].data[0]));
            let tokens = new Map();
            let lp = new Map();
            let spot = new Map();
            let perp = new Map();
            for (var i = 0; i < clientPrimaryAccountHeaderModel.assetsCount; ++i) {
                const offset = structure_models_1.ClientPrimaryAccountHeaderModel.LENGTH + i * 16;
                const assetInfo = primaryData.readUint32LE(offset);
                const tag = assetInfo >> 28;
                const id = assetInfo & 0xFFFFFFF;
                if (tag == 1) {
                    tokens.set(id, {
                        tokenId: id,
                        amount: Number(primaryData.readBigInt64LE(offset + 8)) / this.tokenDec(id)
                    });
                }
                else if (tag == 2) {
                    lp.set(id, {
                        instrId: id,
                        amount: Number(primaryData.readBigInt64LE(offset + 8)) / lpDec
                    });
                }
                else if (tag == 3) {
                    const clientId = primaryData.readUint32LE(offset + 4);
                    const slot = primaryData.readUint32LE(offset + 8);
                    spot.set(id, {
                        instrId: id,
                        clientId: clientId,
                        slot: slot
                    });
                }
                else if (tag == 4) {
                    const clientId = primaryData.readUint32LE(offset + 4);
                    const slot = primaryData.readUint32LE(offset + 8);
                    perp.set(id, {
                        instrId: id,
                        clientId: clientId,
                        slot: slot
                    });
                }
            }
            let clientCommunityRecords = new Map();
            for (var i = 0; i < clientCommunityAccountHeaderModel.count; ++i) {
                const offset = structure_models_1.ClientCommunityAccountHeaderModel.LENGTH + structure_models_1.ClientCommunityRecordModel.LENGTH * i;
                let clientCommunityRecordModel = structure_models_1.ClientCommunityRecordModel.fromBuffer(infos.value[1].data, offset);
                const crncyDec = this.tokenDec(clientCommunityRecordModel.crncyTokenId);
                clientCommunityRecordModel.dividendsValue /= crncyDec;
                clientCommunityRecordModel.feesPrepayment /= crncyDec;
                clientCommunityRecordModel.refPayments /= crncyDec;
                clientCommunityRecords.set(clientCommunityRecordModel.crncyTokenId, clientCommunityRecordModel);
            }
            const drvsDec = this.tokenDec(0);
            clientCommunityAccountHeaderModel.drvsTokens /= drvsDec;
            clientCommunityAccountHeaderModel.currentVotingTokens /= drvsDec;
            clientCommunityAccountHeaderModel.lastVotingTokens /= drvsDec;
            return {
                clientId: clientPrimaryAccountHeaderModel.id,
                mask: clientPrimaryAccountHeaderModel.mask,
                points: clientPrimaryAccountHeaderModel.points,
                slot: clientPrimaryAccountHeaderModel.slot,
                spotTrades: clientPrimaryAccountHeaderModel.spotTrades,
                lpTrades: clientPrimaryAccountHeaderModel.lpTrades,
                perpTrades: clientPrimaryAccountHeaderModel.perpTrades,
                tokens: tokens,
                lp: lp,
                spot: spot,
                perp: perp,
                refProgram: {
                    address: clientPrimaryAccountHeaderModel.refAddress,
                    expiration: clientPrimaryAccountHeaderModel.refProgramExpiration,
                    clientId: clientPrimaryAccountHeaderModel.refClientId,
                    disount: clientPrimaryAccountHeaderModel.refProgramDiscount,
                    ratio: clientPrimaryAccountHeaderModel.refProgramRatio,
                },
                community: {
                    header: clientCommunityAccountHeaderModel,
                    data: clientCommunityRecords
                },
                refLinks: [
                    {
                        id: clientPrimaryAccountHeaderModel.firstRefLinkId,
                        expiration: clientPrimaryAccountHeaderModel.firstRefLinkExpiration,
                        discount: clientPrimaryAccountHeaderModel.firstRefLinkDiscount,
                        ratio: clientPrimaryAccountHeaderModel.firstRefLinkRatio
                    },
                    {
                        id: clientPrimaryAccountHeaderModel.secondRefLinkId,
                        expiration: clientPrimaryAccountHeaderModel.secondRefLinkExpiration,
                        discount: clientPrimaryAccountHeaderModel.secondRefLinkDiscount,
                        ratio: clientPrimaryAccountHeaderModel.secondRefLinkRatio
                    }
                ],
            };
        });
    }
    tokenDec(tokenId) {
        if (this.uiNumbers) {
            const token = this.tokens.get(tokenId);
            if (token) {
                return Math.pow(10, token.mask & 0xFF);
            }
            else {
                return 1;
            }
        }
        else {
            return 1;
        }
    }
    /**
     * Get general information about open orders in particular instrument (spot)
     * @param args Contains data from getClientData function
     * @returns General information about open orders (spot)
     */
    getClientSpotOrdersInfo(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const instr = this.instruments.get(args.instrId);
            if (instr == undefined) {
                throw new Error("Invalid Instrument ID");
            }
            const clientInfosAccount = yield this.getInstrAccountByTag({
                assetTokenId: instr.header.assetTokenId,
                crncyTokenId: instr.header.crncyTokenId,
                tag: types_1.AccountType.SPOT_CLIENT_INFOS
            });
            const clientInfos2Account = yield this.getInstrAccountByTag({
                assetTokenId: instr.header.assetTokenId,
                crncyTokenId: instr.header.crncyTokenId,
                tag: types_1.AccountType.SPOT_CLIENT_INFOS2
            });
            const infos = yield this.rpc.getMultipleAccounts([clientInfosAccount, clientInfos2Account], {
                commitment: this.commitment,
                encoding: 'base64',
                dataSlice: {
                    offset: structure_models_1.SpotTradeAccountHeaderModel.LENGTH + 32 * args.clientId,
                    length: 32
                }
            }).send();
            if (infos.value[0] == null || infos.value[1] == null) {
                throw new Error("Orders Info Not Found");
            }
            const data = buffer_1.Buffer.from((0, kit_1.getBase64Encoder)().encode(infos.value[0].data[0]));
            const data1 = buffer_1.Buffer.from((0, kit_1.getBase64Encoder)().encode(infos.value[1].data[0]));
            return {
                contextSlot: Number(infos.context.slot),
                bidSlot: data1.readUint32LE(structure_models_1.SpotClientInfo2Model.OFFSET_BID_SLOT),
                askSlot: data1.readUint32LE(structure_models_1.SpotClientInfo2Model.OFFSET_ASK_SLOT),
                bidsEntry: data.readUint16LE(structure_models_1.SpotClientInfoModel.OFFSET_BIDS_ENTRY),
                bidsCount: data.readUint16LE(structure_models_1.SpotClientInfoModel.OFFSET_BIDS_ENTRY + 2),
                asksEntry: data.readUint16LE(structure_models_1.SpotClientInfoModel.OFFSET_ASKS_ENTRY),
                asksCount: data.readUint16LE(structure_models_1.SpotClientInfoModel.OFFSET_ASKS_ENTRY + 2),
                tempAssetTokens: Number(data.readBigInt64LE(structure_models_1.SpotClientInfoModel.OFFSET_AVAIL_ASSET_TOKENS)) /
                    this.tokenDec(instr.header.assetTokenId),
                tempCrncyTokens: Number(data.readBigInt64LE(structure_models_1.SpotClientInfoModel.OFFSET_AVAIL_CRNCY_TOKENS)) /
                    this.tokenDec(instr.header.crncyTokenId),
                inOrdersAssetTokens: Number(data1.readBigInt64LE(structure_models_1.SpotClientInfo2Model.OFFSET_IN_ORDERS_ASSET_TOKENS)) /
                    this.tokenDec(instr.header.assetTokenId),
                inOrdersCrncyTokens: Number(data1.readBigInt64LE(structure_models_1.SpotClientInfo2Model.OFFSET_IN_ORDERS_CRNCY_TOKENS)) /
                    this.tokenDec(instr.header.crncyTokenId),
            };
        });
    }
    /**
     * Get general information about open orders in particular instrument (perp)
     * @param args Contains data from getClientData function
     * @returns General information about open orders (perp)
     */
    getClientPerpOrdersInfo(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const instr = this.instruments.get(args.instrId);
            if (instr == undefined) {
                throw new Error("Invalid Instrument ID");
            }
            const clientInfosAccount = yield this.getInstrAccountByTag({
                assetTokenId: instr.header.assetTokenId,
                crncyTokenId: instr.header.crncyTokenId,
                tag: types_1.AccountType.PERP_CLIENT_INFOS
            });
            const clientInfos2Account = yield this.getInstrAccountByTag({
                assetTokenId: instr.header.assetTokenId,
                crncyTokenId: instr.header.crncyTokenId,
                tag: types_1.AccountType.PERP_CLIENT_INFOS2
            });
            const clientInfos3Account = yield this.getInstrAccountByTag({
                assetTokenId: instr.header.assetTokenId,
                crncyTokenId: instr.header.crncyTokenId,
                tag: types_1.AccountType.PERP_CLIENT_INFOS3
            });
            const clientInfos4Account = yield this.getInstrAccountByTag({
                assetTokenId: instr.header.assetTokenId,
                crncyTokenId: instr.header.crncyTokenId,
                tag: types_1.AccountType.PERP_CLIENT_INFOS4
            });
            const clientInfos5Account = yield this.getInstrAccountByTag({
                assetTokenId: instr.header.assetTokenId,
                crncyTokenId: instr.header.crncyTokenId,
                tag: types_1.AccountType.PERP_CLIENT_INFOS5
            });
            const infos = yield this.rpc.getMultipleAccounts([clientInfosAccount, clientInfos2Account, clientInfos3Account, clientInfos4Account, clientInfos5Account], {
                commitment: this.commitment,
                encoding: 'base64',
                dataSlice: {
                    offset: structure_models_1.SpotTradeAccountHeaderModel.LENGTH + 32 * args.clientId,
                    length: 32
                }
            }).send();
            if (infos.value[0] == null || infos.value[1] == null || infos.value[2] == null ||
                infos.value[3] == null || infos.value[4] == null) {
                throw new Error("Orders Info Not Found");
            }
            const clientInfoModel = structure_models_1.PerpClientInfoModel.fromBuffer(infos.value[0].data);
            const clientInfo2Model = structure_models_1.PerpClientInfo2Model.fromBuffer(infos.value[1].data);
            const clientInfo3Model = structure_models_1.PerpClientInfo3Model.fromBuffer(infos.value[2].data);
            const clientInfo4Model = structure_models_1.PerpClientInfo4Model.fromBuffer(infos.value[3].data);
            const clientInfo5Model = structure_models_1.PerpClientInfo5Model.fromBuffer(infos.value[4].data);
            return {
                contextSlot: Number(infos.context.slot),
                bidSlot: clientInfo2Model.bidSlot,
                askSlot: clientInfo2Model.askSlot,
                bidsEntry: clientInfo3Model.bidsEntry & 0xFFFF,
                bidsCount: clientInfo3Model.bidsEntry >> 16,
                asksEntry: clientInfo3Model.asksEntry & 0xFFFF,
                asksCount: clientInfo3Model.asksEntry >> 16,
                perps: clientInfoModel.perps,
                funds: clientInfoModel.funds,
                inOrdersPerps: clientInfoModel.inOrdersPerps,
                inOrdersFunds: clientInfoModel.inOrdersFunds,
                fees: clientInfo3Model.fees,
                rebates: clientInfo3Model.rebates,
                result: clientInfo2Model.result,
                cost: clientInfo2Model.cost,
                mask: clientInfo2Model.mask,
                socLossFunds: clientInfo4Model.socLossFunds,
                fundingFunds: clientInfo5Model.fundingFunds,
                lossCoverage: clientInfo4Model.lossCoverage
            };
        });
    }
    /**
     * Get list of open orders (spot) in particular instrument
     * @param args Contains data from getClientSpotOrdersInfo
     * @returns List of open orders
     */
    getClientSpotOrders(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const instr = this.instruments.get(args.instrId);
            const bidOrdersAccount = yield this.getInstrAccountByTag({
                assetTokenId: instr.header.assetTokenId,
                crncyTokenId: instr.header.crncyTokenId,
                tag: types_1.AccountType.SPOT_BID_ORDERS
            });
            const askOrdersAccount = yield this.getInstrAccountByTag({
                assetTokenId: instr.header.assetTokenId,
                crncyTokenId: instr.header.crncyTokenId,
                tag: types_1.AccountType.SPOT_ASK_ORDERS
            });
            const assetTokenDec = this.tokenDec(instr.header.assetTokenId);
            const crncyTokenDec = this.tokenDec(instr.header.crncyTokenId);
            if (args.bidsCount > 1 && args.asksCount > 1) {
                let infos = yield this.rpc.getMultipleAccounts([bidOrdersAccount, askOrdersAccount], { commitment: this.commitment, encoding: 'base64' }).send();
                let bids = getMultipleSpotOrders(infos.value[0].data, args.bidsEntry, this.originalClientId);
                for (let i = 0; i < bids.length; ++i) {
                    bids[i].qty /= assetTokenDec;
                    bids[i].sum /= crncyTokenDec;
                }
                let asks = getMultipleSpotOrders(infos.value[1].data, args.asksEntry, this.originalClientId);
                for (let i = 0; i < asks.length; ++i) {
                    asks[i].qty /= assetTokenDec;
                    asks[i].sum /= crncyTokenDec;
                }
                return {
                    contextSlot: Number(infos.context.slot),
                    bids: bids,
                    asks: asks
                };
            }
            let bids = [];
            let asks = [];
            let bidContextSlot = 0;
            let askContextSlot = 0;
            if (args.bidsCount > 1) {
                let info = yield this.rpc.getAccountInfo(bidOrdersAccount, {
                    commitment: this.commitment,
                    encoding: 'base64'
                }).send();
                bidContextSlot = Number(info.context.slot);
                bids = getMultipleSpotOrders(info.value.data, args.bidsEntry, this.originalClientId);
            }
            else if (args.bidsCount == 1) {
                let info = yield this.rpc.getAccountInfo(bidOrdersAccount, {
                    commitment: this.commitment,
                    encoding: 'base64',
                    dataSlice: {
                        offset: args.bidsEntry * 64 + structure_models_1.SpotTradeAccountHeaderModel.LENGTH,
                        length: 64
                    }
                }).send();
                const order = structure_models_1.OrderModel.fromBuffer(info.value.data);
                if (order.origClientId == this.originalClientId) {
                    bids = [order];
                }
                bidContextSlot = Number(info.context.slot);
            }
            if (args.asksCount > 1) {
                let info = yield this.rpc.getAccountInfo(askOrdersAccount, {
                    commitment: this.commitment,
                    encoding: 'base64'
                }).send();
                askContextSlot = Number(info.context.slot);
                asks = getMultipleSpotOrders(info.value.data, args.bidsEntry, this.originalClientId);
            }
            else if (args.asksCount == 1) {
                let info = yield this.rpc.getAccountInfo(askOrdersAccount, {
                    commitment: this.commitment,
                    encoding: 'base64',
                    dataSlice: {
                        offset: args.asksEntry * 64 + structure_models_1.SpotTradeAccountHeaderModel.LENGTH,
                        length: 64
                    }
                }).send();
                const order = structure_models_1.OrderModel.fromBuffer(info.value.data);
                if (order.origClientId == this.originalClientId) {
                    asks = [order];
                }
                askContextSlot = Number(info.context.slot);
            }
            for (let i = 0; i < bids.length; ++i) {
                bids[i].qty /= assetTokenDec;
                bids[i].sum /= crncyTokenDec;
            }
            for (let i = 0; i < asks.length; ++i) {
                asks[i].qty /= assetTokenDec;
                asks[i].sum /= crncyTokenDec;
            }
            let contextSlot = 0;
            if (bidContextSlot > 0 || askContextSlot > 0) {
                if (bidContextSlot == 0) {
                    contextSlot = askContextSlot;
                }
                else if (askContextSlot == 0) {
                    contextSlot = bidContextSlot;
                }
                else {
                    contextSlot = Math.min(bidContextSlot, askContextSlot);
                }
            }
            return {
                contextSlot: contextSlot,
                bids: bids,
                asks: asks
            };
        });
    }
    /**
     * Get list of open orders (perp) in particular instrument
     * @param args Contains data from getClientSpotOrdersInfo
     * @returns List of open orders
     */
    getClientPerpOrders(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const instr = this.instruments.get(args.instrId);
            const bidOrdersAccount = yield this.getInstrAccountByTag({
                assetTokenId: instr.header.assetTokenId,
                crncyTokenId: instr.header.crncyTokenId,
                tag: types_1.AccountType.PERP_BID_ORDERS
            });
            const askOrdersAccount = yield this.getInstrAccountByTag({
                assetTokenId: instr.header.assetTokenId,
                crncyTokenId: instr.header.crncyTokenId,
                tag: types_1.AccountType.PERP_ASK_ORDERS
            });
            const assetTokenDec = this.tokenDec(instr.header.assetTokenId);
            const crncyTokenDec = this.tokenDec(instr.header.crncyTokenId);
            if (args.bidsCount > 1 && args.asksCount > 1) {
                let infos = yield this.rpc.getMultipleAccounts([bidOrdersAccount, askOrdersAccount], { commitment: this.commitment, encoding: 'base64' }).send();
                let bids = getMultiplePerpOrders(infos.value[0].data, args.bidsEntry, this.originalClientId);
                for (let i = 0; i < bids.length; ++i) {
                    bids[i].qty /= assetTokenDec;
                    bids[i].sum /= crncyTokenDec;
                }
                let asks = getMultiplePerpOrders(infos.value[1].data, args.asksEntry, this.originalClientId);
                for (let i = 0; i < asks.length; ++i) {
                    asks[i].qty /= assetTokenDec;
                    asks[i].sum /= crncyTokenDec;
                }
                return {
                    contextSlot: Number(infos.context.slot),
                    bids: bids,
                    asks: asks
                };
            }
            let bids = [];
            let asks = [];
            let bidContextSlot = 0;
            let askContextSlot = 0;
            if (args.bidsCount > 1) {
                let info = yield this.rpc.getAccountInfo(bidOrdersAccount, { commitment: this.commitment, encoding: 'base64' }).send();
                bidContextSlot = Number(info.context.slot);
                bids = getMultiplePerpOrders(info.value.data, args.bidsEntry, this.originalClientId);
            }
            else if (args.bidsCount == 1) {
                let info = yield this.rpc.getAccountInfo(bidOrdersAccount, {
                    commitment: this.commitment,
                    encoding: 'base64',
                    dataSlice: {
                        offset: args.bidsEntry * 64 + structure_models_1.PerpTradeAccountHeaderModel.LENGTH,
                        length: 64
                    }
                }).send();
                const order = structure_models_1.OrderModel.fromBuffer(info.value.data);
                if (order.origClientId == this.originalClientId) {
                    bids = [order];
                }
                bidContextSlot = Number(info.context.slot);
            }
            if (args.asksCount > 1) {
                let info = yield this.rpc.getAccountInfo(askOrdersAccount, { commitment: this.commitment, encoding: 'base64' }).send();
                askContextSlot = Number(info.context.slot);
                asks = getMultiplePerpOrders(info.value.data, args.bidsEntry, this.originalClientId);
            }
            else if (args.asksCount == 1) {
                let info = yield this.rpc.getAccountInfo(askOrdersAccount, {
                    commitment: this.commitment,
                    encoding: 'base64',
                    dataSlice: {
                        offset: args.asksEntry * 64 + structure_models_1.PerpTradeAccountHeaderModel.LENGTH,
                        length: 64
                    }
                }).send();
                const order = structure_models_1.OrderModel.fromBuffer(info.value.data);
                if (order.origClientId == this.originalClientId) {
                    asks = [order];
                }
                askContextSlot = Number(info.context.slot);
            }
            for (let i = 0; i < bids.length; ++i) {
                bids[i].qty /= assetTokenDec;
                bids[i].sum /= crncyTokenDec;
            }
            for (let i = 0; i < asks.length; ++i) {
                asks[i].qty /= assetTokenDec;
                asks[i].sum /= crncyTokenDec;
            }
            let contextSlot = 0;
            if (bidContextSlot > 0 || askContextSlot > 0) {
                if (bidContextSlot == 0) {
                    contextSlot = askContextSlot;
                }
                else if (askContextSlot == 0) {
                    contextSlot = bidContextSlot;
                }
                else {
                    contextSlot = Math.min(bidContextSlot, askContextSlot);
                }
            }
            return {
                contextSlot: contextSlot,
                bids: bids,
                asks: asks
            };
        });
    }
    /**
     * Unpack market data to Engine fields, you can use this function to subscribe to Solana account
     * @param buf Engine Instrument Dynamic Account data
     */
    updateInstrDataFromBuffer(data) {
        return __awaiter(this, void 0, void 0, function* () {
            let header = structure_models_1.InstrAccountHeaderModel.fromBuffer(data);
            header.ps /= lpDec;
            const assetTokenDec = this.tokenDec(header.assetTokenId);
            const crncyTokenDec = this.tokenDec(header.crncyTokenId);
            header.assetTokens /= assetTokenDec;
            header.crncyTokens /= crncyTokenDec;
            header.protocolFees /= crncyTokenDec;
            header.lastAssetTokens /= assetTokenDec;
            header.lastCrncyTokens /= crncyTokenDec;
            header.dayAssetTokens /= assetTokenDec;
            header.dayCrncyTokens /= crncyTokenDec;
            header.prevDayAssetTokens /= assetTokenDec;
            header.prevDayCrncyTokens /= crncyTokenDec;
            header.perpLastTradeAssetTokens /= assetTokenDec;
            header.perpLastTradeCrncyTokens /= crncyTokenDec;
            header.perpDayAssetTokens /= assetTokenDec;
            header.perpDayCrncyTokens /= crncyTokenDec;
            header.fixingAssetTokens /= assetTokenDec;
            header.fixingCrncyTokens /= crncyTokenDec;
            header.perpFundingFunds /= crncyTokenDec;
            header.perpInsuranceFund /= crncyTokenDec;
            header.perpOpenInt /= assetTokenDec;
            header.perpSocLossFunds /= crncyTokenDec;
            header.perpPrevDayAssetTokens /= assetTokenDec;
            header.perpPrevDayCrncyTokens /= crncyTokenDec;
            header.bestBid /= dec;
            header.bestAsk /= dec;
            header.dayHigh /= dec;
            header.dayLow /= dec;
            header.perpBestBid /= dec;
            header.perpBestAsk /= dec;
            header.perpDayHigh /= dec;
            header.perpDayLow /= dec;
            header.lastPx /= dec;
            header.perpUnderlyingPx /= dec;
            header.lastClose /= dec;
            header.fixingPx /= dec;
            header.perpLastClose /= dec;
            header.perpLastPx /= dec;
            header.perpLongSpotPriceForWithdrowal /= dec;
            header.perpShortSpotPriceForWithdrowal /= dec;
            header.poolFees /= crncyTokenDec;
            let spotBids = [];
            let spotAsks = [];
            let perpBids = [];
            let perpAsks = [];
            for (var i = 0; i < types_1.MARKET_DEPTH; ++i) {
                const offset = structure_models_1.InstrAccountHeaderModel.LENGTH + i * 16;
                let line = structure_models_1.LineQuotesModel.fromBuffer(data, offset);
                if (line.px == 0) {
                    break;
                }
                line.px /= dec;
                line.qty /= assetTokenDec;
                spotBids.push(line);
            }
            for (var i = 0; i < types_1.MARKET_DEPTH; ++i) {
                const offset = structure_models_1.InstrAccountHeaderModel.LENGTH + i * 16 + 16 * types_1.MARKET_DEPTH;
                let line = structure_models_1.LineQuotesModel.fromBuffer(data, offset);
                if (line.px == 0) {
                    break;
                }
                line.px /= dec;
                line.qty /= assetTokenDec;
                spotAsks.push(line);
            }
            for (var i = 0; i < types_1.MARKET_DEPTH; ++i) {
                const offset = structure_models_1.InstrAccountHeaderModel.LENGTH + i * 16 + 16 * types_1.MARKET_DEPTH * 2;
                let line = structure_models_1.LineQuotesModel.fromBuffer(data, offset);
                if (line.px == 0) {
                    break;
                }
                line.px /= dec;
                line.qty /= assetTokenDec;
                perpBids.push(line);
            }
            for (var i = 0; i < types_1.MARKET_DEPTH; ++i) {
                const offset = structure_models_1.InstrAccountHeaderModel.LENGTH + i * 16 + 16 * types_1.MARKET_DEPTH * 3;
                let line = structure_models_1.LineQuotesModel.fromBuffer(data, offset);
                if (line.px == 0) {
                    break;
                }
                line.px /= dec;
                line.qty /= assetTokenDec;
                perpAsks.push(line);
            }
            let pattern = buffer_1.Buffer.alloc(16);
            pattern.writeInt32LE(this.version, 0);
            pattern.writeInt32LE(types_1.AccountType.INSTR, 4);
            pattern.writeInt32LE(header.assetTokenId, 8);
            pattern.writeInt32LE(header.crncyTokenId, 12);
            const instrAddress = (yield (0, kit_1.getProgramDerivedAddress)({
                programAddress: this.programId,
                seeds: [pattern, (0, kit_1.getAddressEncoder)().encode(this.drvsAuthority)]
            }))[0];
            this.instruments.set(header.instrId, {
                address: instrAddress,
                header: header,
                spotBids: spotBids,
                spotAsks: spotAsks,
                perpBids: perpBids,
                perpAsks: perpAsks
            });
        });
    }
    /**
     * Get AddressLookupTableAccount to compile Versioned Transaction with this instrument (spot + derivatives)
     * @param args Instrument ID
     * @returns AddressLookupTableAccount for instrument
     */
    instrLut(args) {
        return this.instruments.get(args.instrId).header.lutAddress;
    }
    /**
     * Update market data on Engine fields
     * @param args Instrument ID
     */
    updateInstrData(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const instr = this.instruments.get(args.instrId);
            let instrAccount = yield this.getInstrAccountByTag({
                assetTokenId: instr.header.assetTokenId,
                crncyTokenId: instr.header.crncyTokenId,
                tag: types_1.AccountType.INSTR
            });
            const info = yield this.rpc.getAccountInfo(instrAccount, { commitment: this.commitment, encoding: 'base64' }).send();
            yield this.updateInstrDataFromBuffer(info.value.data);
        });
    }
    /**
      * Build instruction to deposit SPL tokens
      * @param args Order data
      * @returns Transaction instruction
      */
    depositInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const exists = yield this.checkClient();
            if (this.signer == null) {
                throw new Error("Wallet is not connected");
            }
            const amount = (_a = args.amount) !== null && _a !== void 0 ? _a : 0;
            const allFunds = args.all_funds ? 1 : 0;
            const token = this.tokens.get(args.tokenId);
            const tokenProgramId = (token.mask & 0x80000000) != 0 ? TOKEN_2022_PROGRAM_ID : TOKEN_PROGRAM_ID;
            const clientTokenAccount = yield findAssociatedTokenAddress(this.signer, tokenProgramId, token.address);
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: clientTokenAccount, role: kit_1.AccountRole.WRITABLE },
                { address: token.programAddress, role: kit_1.AccountRole.WRITABLE },
                { address: token.address, role: kit_1.AccountRole.READONLY },
                { address: this.rootAccount, role: exists ? kit_1.AccountRole.READONLY : kit_1.AccountRole.WRITABLE },
                { address: yield this.getTokenAccount(token.address), role: kit_1.AccountRole.READONLY },
                { address: yield this.findClientPrimaryAccount(), role: kit_1.AccountRole.WRITABLE },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
                { address: tokenProgramId, role: kit_1.AccountRole.READONLY },
            ];
            if (this.privateMode) {
                keys.push({ address: yield this.getAccountByTag(types_1.AccountType.PRIVATE_CLIENTS), role: kit_1.AccountRole.WRITABLE });
            }
            if (exists) {
                if (args.tokenId == 0) {
                    keys.push({ address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY), role: kit_1.AccountRole.WRITABLE });
                    keys.push({ address: this.clientCommunityAccount, role: kit_1.AccountRole.WRITABLE });
                }
                return {
                    accounts: keys,
                    programAddress: this.programId,
                    data: (0, instruction_models_1.depositData)(7, 0, allFunds, args.tokenId, amount * this.tokenDec(args.tokenId), 0, 0)
                };
            }
            else {
                const slot = Number((yield this.rpc.getSlot().send())) - 1;
                const lutAddress = yield getLookupTableAddress(this.signer, slot);
                const clientCommunityAccount = yield this.findClientCommunityAccount();
                keys.push({ address: clientCommunityAccount, role: kit_1.AccountRole.WRITABLE });
                keys.push({ address: lutAddress, role: kit_1.AccountRole.WRITABLE });
                keys.push({ address: ADDRESS_LOOKUP_TABLE_PROGRAM_ID, role: kit_1.AccountRole.WRITABLE });
                if (args.tokenId == 0) {
                    keys.push({ address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY), role: kit_1.AccountRole.WRITABLE });
                    keys.push({ address: clientCommunityAccount, role: kit_1.AccountRole.WRITABLE });
                }
                let refId;
                if (args.refId != null && args.refId != undefined) {
                    refId = args.refId;
                    if (args.refWallet == null || args.refWallet == undefined) {
                        throw new Error("Ref Wallet Not Found");
                    }
                    keys.push({ address: yield this.findClientPrimaryAccount(args.refWallet), role: kit_1.AccountRole.WRITABLE });
                    keys.push({ address: yield this.findClientCommunityAccount(args.refWallet), role: kit_1.AccountRole.WRITABLE });
                }
                else {
                    refId = 0;
                }
                return {
                    accounts: keys,
                    programAddress: this.programId,
                    data: (0, instruction_models_1.depositData)(7, 0, allFunds, args.tokenId, amount * this.tokenDec(args.tokenId), slot, refId)
                };
            }
        });
    }
    /**
     * Build instruction to withdraw SPL tokens
     * @param args Order data
     * @returns Transaction instruction
     */
    withdrawInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            const token = this.tokens.get(args.tokenId);
            const tokenProgramId = (token.mask & 0x80000000) != 0 ? TOKEN_2022_PROGRAM_ID : TOKEN_PROGRAM_ID;
            const clientTokenAccount = yield findAssociatedTokenAddress(this.signer, tokenProgramId, token.address);
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: clientTokenAccount, role: kit_1.AccountRole.WRITABLE },
                { address: token.programAddress, role: kit_1.AccountRole.WRITABLE },
                { address: token.address, role: kit_1.AccountRole.READONLY },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: yield this.getTokenAccount(token.address), role: kit_1.AccountRole.READONLY },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
                { address: tokenProgramId, role: kit_1.AccountRole.READONLY },
                { address: this.drvsAuthority, role: kit_1.AccountRole.READONLY },
                { address: ASSOCIATED_TOKEN_PROGRAM_ID, role: kit_1.AccountRole.WRITABLE },
            ];
            if (args.spot != undefined) {
                for (var i = 0; i < args.spot.length; ++i) {
                    const instr = this.instruments.get(args.spot[i].instrId);
                    if (instr.header.assetTokenId == args.tokenId || instr.header.crncyTokenId == args.tokenId) {
                        keys.push({ address: instr.header.mapsAddress, role: kit_1.AccountRole.READONLY });
                        keys.push({
                            address: yield this.getInstrAccountByTag({
                                assetTokenId: instr.header.assetTokenId,
                                crncyTokenId: instr.header.crncyTokenId,
                                tag: types_1.AccountType.SPOT_CLIENT_INFOS
                            }),
                            role: kit_1.AccountRole.READONLY
                        });
                    }
                }
            }
            if (args.tokenId == 0) {
                keys.push({ address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY), role: kit_1.AccountRole.WRITABLE });
                keys.push({ address: yield this.clientCommunityAccount, role: kit_1.AccountRole.WRITABLE });
            }
            return {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.withdrawData)(8, args.tokenId, args.amount * this.tokenDec(args.tokenId))
            };
        });
    }
    /**
     * Build instruction to trade spot LP tokens in particular instrument
     * @param args Order data
     * @returns Trabsaction instruction
     */
    spotLpInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            yield this.updateInstrData({ instrId: args.instrId });
            let instr = this.instruments.get(args.instrId);
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.INSTR
                    }),
                    role: kit_1.AccountRole.WRITABLE
                },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            if (instr.header.assetTokenId == 0) {
                keys.push({ address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY), role: kit_1.AccountRole.WRITABLE });
                keys.push({ address: this.clientCommunityAccount, role: kit_1.AccountRole.WRITABLE });
            }
            const minPrice = (args.minPrice == undefined || args.minPrice == null) ? 0 : args.minPrice;
            const maxPrice = (args.maxPrice == undefined || args.maxPrice == null) ? 0 : args.maxPrice;
            return {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.spotLpData)(14, args.side, args.instrId, Math.round(args.amount * lpDec), minPrice * 1000000000, maxPrice * 1000000000),
            };
        });
    }
    /**
     * Build instruction to add new spot order in particular instrument
     * @param args Order data
     * @returns Transaction instruction
     */
    newSpotOrderInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            let instr = this.instruments.get(args.instrId);
            if (instr.header.mapsAddress == undefined) {
                yield this.updateInstrData({ instrId: args.instrId });
                instr = this.instruments.get(args.instrId);
            }
            let buf = (0, instruction_models_1.newSpotOrderData)(12, args.ioc == null || args.ioc == undefined ? 0 : args.ioc, args.orderType == null || args.orderType == undefined ? 0 : args.orderType, args.side, args.instrId, Math.round(args.price * 1000000000), Math.round(args.qty * this.tokenDec(instr.header.assetTokenId)), args.edgePrice == null || args.edgePrice == undefined ? 0 : args.edgePrice * 1000000000);
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: yield this.findClientPrimaryAccount(), role: kit_1.AccountRole.WRITABLE },
                { address: yield this.findClientCommunityAccount(), role: kit_1.AccountRole.WRITABLE },
                ...yield this.getSpotContext(instr.header),
                ...yield this.getSpotCandles(instr.header),
                {
                    address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY),
                    role: instr.header.assetTokenId == 0 ? kit_1.AccountRole.WRITABLE : kit_1.AccountRole.READONLY
                },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            if (this.refClientPrimaryAccount != null && this.refClientPrimaryAccount != undefined) {
                keys.push({ address: this.refClientPrimaryAccount, role: kit_1.AccountRole.WRITABLE });
                keys.push({ address: this.refClientCommunityAccount, role: kit_1.AccountRole.WRITABLE });
            }
            return {
                accounts: keys, programAddress: this.programId, data: buf
            };
        });
    }
    /**
     * Build instruction to spot quotes replacement in particular instrument
     * @param args Order data
     * @returns Transaction instruction
     */
    spotQuotesReplaceInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            let instr = this.instruments.get(args.instrId);
            if (instr.header.mapsAddress == undefined) {
                yield this.updateInstrData({ instrId: args.instrId });
                instr = this.instruments.get(args.instrId);
            }
            let assetTokenDecFactor = this.tokenDec(instr.header.assetTokenId);
            let buf = (0, instruction_models_1.spotQuotesReplaceData)(34, args.instrId, Math.round(args.newBidPrice * 1000000000), Math.round(args.newBidQty * assetTokenDecFactor), args.bidOrderIdToCancel, Math.round(args.newAskPrice * 1000000000), Math.round(args.newAskQty * assetTokenDecFactor), args.askOrderIdToCancel);
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: yield this.findClientPrimaryAccount(), role: kit_1.AccountRole.WRITABLE },
                { address: yield this.findClientCommunityAccount(), role: kit_1.AccountRole.WRITABLE },
                ...yield this.getSpotContext(instr.header),
                ...yield this.getSpotCandles(instr.header),
                {
                    address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY),
                    role: instr.header.assetTokenId == 0 ? kit_1.AccountRole.WRITABLE : kit_1.AccountRole.READONLY
                },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            if (this.refClientPrimaryAccount != null && this.refClientPrimaryAccount != undefined) {
                keys.push({ address: this.refClientPrimaryAccount, role: kit_1.AccountRole.WRITABLE });
                keys.push({ address: this.refClientCommunityAccount, role: kit_1.AccountRole.WRITABLE });
            }
            return {
                accounts: keys, programAddress: this.programId, data: buf
            };
        });
    }
    /**
     * Build instruction to cancel spot order in particular instrument
     * @param args Order data
     * @returns Transaction instruction
     */
    spotOrderCancelInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            let instr = this.instruments.get(args.instrId);
            if (instr.header.mapsAddress == undefined) {
                yield this.updateInstrData({ instrId: args.instrId });
                instr = this.instruments.get(args.instrId);
            }
            const drvs = instr.header.assetTokenId == 0;
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
                ...yield this.getSpotContext(instr.header),
                {
                    address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY),
                    role: drvs ? kit_1.AccountRole.WRITABLE : kit_1.AccountRole.READONLY
                },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            if (drvs) {
                keys.push({ address: yield this.findClientCommunityAccount(), role: kit_1.AccountRole.WRITABLE });
            }
            return {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.spotOrderCancelData)(13, args.side, args.instrId, args.orderId),
            };
        });
    }
    /**
     * Build instruction for spot mass cancel in particular instrument
     * @param args Order data
     * @returns Transaction instruction
     */
    spotMassCancelInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            let instr = this.instruments.get(args.instrId);
            if (instr.header.mapsAddress == undefined) {
                yield this.updateInstrData({ instrId: args.instrId });
                instr = this.instruments.get(args.instrId);
            }
            const drvs = instr.header.assetTokenId == 0;
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
                ...yield this.getSpotContext(instr.header),
                {
                    address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY),
                    role: drvs ? kit_1.AccountRole.WRITABLE : kit_1.AccountRole.READONLY
                },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            if (drvs) {
                keys.push({ address: yield this.findClientCommunityAccount(), role: kit_1.AccountRole.WRITABLE });
            }
            return {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.spotMassCancelData)(15, args.instrId),
            };
        });
    }
    /**
       * Build upgrade to PERP instructions
       * @param args Order data
       * @returns Transaction instruction
       */
    upgradeToPerpInstructions(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.signer == null) {
                throw new Error("Wallet is not connected");
            }
            let instr = this.instruments.get(args.instrId);
            if (instr == null) {
                throw new Error("Invalid Instr ID");
            }
            yield this.updateInstrData({
                instrId: args.instrId
            });
            instr = this.instruments.get(args.instrId);
            if ((instr.header.mask & types_1.InstrMask.READY_TO_PERP_UPGRADE) == 0) {
                throw new Error("Impossible to upgrade");
            }
            if ((instr.header.mask & types_1.InstrMask.PERP) != 0) {
                throw new Error("Instr already upgraded");
            }
            const perpMapsAccountSeed = this.version.toString() + "_" +
                types_1.AccountType.PERP_MAPS.toString() + "_" +
                instr.header.assetTokenId.toString() + "_" +
                instr.header.crncyTokenId.toString();
            const perpMapsAccount = yield (0, kit_1.createAddressWithSeed)({
                baseAddress: this.signer,
                programAddress: this.programId,
                seed: perpMapsAccountSeed
            });
            const perpMapsAccountSize = 168576;
            const perpMapsAccountLamports = yield this.rpc.getMinimumBalanceForRentExemption(BigInt(perpMapsAccountSize)).send();
            const createMapsAccountIx = (0, system_1.getCreateAccountWithSeedInstruction)({
                payer: this.signer,
                baseAccount: this.signer,
                base: this.signer,
                newAccount: perpMapsAccount,
                seed: perpMapsAccountSeed,
                space: perpMapsAccountSize,
                programAddress: this.programId,
                amount: perpMapsAccountLamports,
            });
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.WRITABLE },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.INSTR
                    }), role: kit_1.AccountRole.WRITABLE
                },
                { address: instr.header.lutAddress, role: kit_1.AccountRole.WRITABLE },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
                { address: ADDRESS_LOOKUP_TABLE_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
                { address: this.drvsAuthority, role: kit_1.AccountRole.READONLY },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.PERP_BIDS_TREE
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.PERP_ASKS_TREE
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.PERP_BID_ORDERS
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.PERP_ASK_ORDERS
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.PERP_LINES
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: perpMapsAccount, role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.PERP_CLIENT_INFOS
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.PERP_CLIENT_INFOS2
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.PERP_CLIENT_INFOS3
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.PERP_CLIENT_INFOS4
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.PERP_CLIENT_INFOS5
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.PERP_LONG_PX_TREE
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.PERP_SHORT_PX_TREE
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: instr.header.assetTokenId,
                        crncyTokenId: instr.header.crncyTokenId,
                        tag: types_1.AccountType.PERP_REBALANCE_TIME_TREE
                    }), role: kit_1.AccountRole.WRITABLE
                },
            ];
            const upgradeIx = {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.upgradeToPerpData)(10, args.instrId)
            };
            return [createMapsAccountIx, upgradeIx];
        });
    }
    /**
     * Build instruction for perp deposit in particular instrument
     * @param args Order data
     * @returns Transaction instruction
     */
    perpDepositInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            let instr = this.instruments.get(args.instrId);
            if (instr.header.perpMapsAddress == undefined) {
                yield this.updateInstrData({ instrId: args.instrId });
                instr = this.instruments.get(args.instrId);
            }
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
                ...yield this.getPerpContext(instr.header),
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            return {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.perpDepositData)(11, args.instrId, args.amount * this.tokenDec(instr.header.crncyTokenId)),
            };
        });
    }
    /**
     * Build instruction for perp buy seat in particular instrument
     * @param args Order data
     * @returns Transaction instruction
     */
    perpBuySeatInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            yield this.updateInstrData({ instrId: args.instrId });
            let instr = this.instruments.get(args.instrId);
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
                ...yield this.getPerpContext(instr.header),
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            const splippage = (args.slippage == undefined || args.slippage == null) ? 0 : args.slippage;
            const slippagePrice = (perpSeatReserve(instr.header.perpClientsCount + 1) -
                perpSeatReserve(instr.header.perpClientsCount)) * (1 + splippage);
            const crncyDec = this.tokenDec(instr.header.crncyTokenId);
            return {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.buyMarketSeatData)(47, args.instrId, slippagePrice * crncyDec, args.amount * crncyDec),
            };
        });
    }
    perpSellSeatInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            yield this.updateInstrData({ instrId: args.instrId });
            let instr = this.instruments.get(args.instrId);
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
                ...yield this.getPerpContext(instr.header),
                { address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY), role: kit_1.AccountRole.READONLY },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            const splippage = (args.slippage == undefined || args.slippage == null) ? 0 : args.slippage;
            const slippagePrice = (perpSeatReserve(instr.header.perpClientsCount + 1) -
                perpSeatReserve(instr.header.perpClientsCount)) / (1 + splippage);
            const crncyDec = this.tokenDec(instr.header.crncyTokenId);
            return {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.sellMarketSeatData)(48, slippagePrice * crncyDec, args.instrId),
            };
        });
    }
    /**
     * Build instruction for new perp order in particular instrument
     * @param args Order data
     * @returns Transaction instruction
     */
    newPerpOrderInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            let instr = this.instruments.get(args.instrId);
            if (instr.header.perpMapsAddress == undefined) {
                yield this.updateInstrData({ instrId: args.instrId });
                instr = this.instruments.get(args.instrId);
            }
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
                { address: this.clientCommunityAccount, role: kit_1.AccountRole.WRITABLE },
                ...yield this.getPerpContext(instr.header),
                { address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY), role: kit_1.AccountRole.READONLY },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            if (this.refClientPrimaryAccount != null && this.refClientPrimaryAccount != undefined) {
                keys.push({ address: this.refClientPrimaryAccount, role: kit_1.AccountRole.WRITABLE });
                keys.push({ address: this.refClientCommunityAccount, role: kit_1.AccountRole.WRITABLE });
            }
            return {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.newPerpOrderData)(19, args.ioc == null || args.ioc == undefined ? 0 : args.ioc, args.leverage == null || args.leverage == undefined ? 0 : args.leverage, args.orderType == null || args.orderType == undefined ? 0 : args.orderType, args.side, args.instrId, args.price * 1000000000, args.qty * this.tokenDec(instr.header.assetTokenId), args.edgePrice == null || args.edgePrice == undefined ? 0 : args.edgePrice * 1000000000),
            };
        });
    }
    /**
     * Build instruction for perp quotes replace in particular instrument
     * @param args Order data
     * @returns Transaction instruction
     */
    perpQuotesReplaceInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            let instr = this.instruments.get(args.instrId);
            if (instr.header.perpMapsAddress == undefined) {
                yield this.updateInstrData({ instrId: args.instrId });
                instr = this.instruments.get(args.instrId);
            }
            let assetTokenDecFactor = this.tokenDec(instr.header.assetTokenId);
            let buf = (0, instruction_models_1.perpQuotesReplaceData)(42, args.instrId, Math.round(args.newBidPrice * 1000000000), Math.round(args.newBidQty * assetTokenDecFactor), args.bidOrderIdToCancel, Math.round(args.newAskPrice * 1000000000), Math.round(args.newAskQty * assetTokenDecFactor), args.askOrderIdToCancel);
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
                { address: this.clientCommunityAccount, role: kit_1.AccountRole.WRITABLE },
                ...yield this.getPerpContext(instr.header),
                { address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY), role: kit_1.AccountRole.READONLY },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            if (this.refClientPrimaryAccount != null && this.refClientPrimaryAccount != undefined) {
                keys.push({ address: this.refClientPrimaryAccount, role: kit_1.AccountRole.WRITABLE });
                keys.push({ address: this.refClientCommunityAccount, role: kit_1.AccountRole.WRITABLE });
            }
            return {
                accounts: keys,
                programAddress: this.programId,
                data: buf,
            };
        });
    }
    /**
     * Build instruction for perp order cancel in particular instrument
     * @param args Order data
     * @returns Transaction instruction
     */
    perpOrderCancelInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            let instr = this.instruments.get(args.instrId);
            if (instr.header.perpMapsAddress == undefined) {
                yield this.updateInstrData({ instrId: args.instrId });
                instr = this.instruments.get(args.instrId);
            }
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
                ...yield this.getPerpContext(instr.header),
                { address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY), role: kit_1.AccountRole.READONLY },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            return {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.perpOrderCancelData)(30, args.side, args.instrId, args.orderId),
            };
        });
    }
    /**
     * Build instruction for perp mass cancel in particular instrument
     * @param args Order data
     * @returns Transaction instruction
     */
    perpMassCancelInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            let instr = this.instruments.get(args.instrId);
            if (instr.header.perpMapsAddress == undefined) {
                yield this.updateInstrData({ instrId: args.instrId });
                instr = this.instruments.get(args.instrId);
            }
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
                ...yield this.getPerpContext(instr.header),
                { address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY), role: kit_1.AccountRole.READONLY },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            return {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.perpMassCancelData)(36, args.instrId),
            };
        });
    }
    /**
     * Build instruction for new referral link
     * @returns Transaction instruction
    */
    newRefLinkInstruction() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            let buf = buffer_1.Buffer.alloc(1);
            buf.writeUInt8(45, 0);
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.WRITABLE },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
            ];
            return {
                accounts: keys,
                programAddress: this.programId,
                data: buf,
            };
        });
    }
    /**
     * Build instruction for change leverage in particular instrument
     * @param args Transaction data
     * @returns Transaction instruction
     */
    perpChangeLeverageInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            let instr = this.instruments.get(args.instrId);
            if (instr.header.perpMapsAddress == undefined) {
                yield this.updateInstrData({ instrId: args.instrId });
                instr = this.instruments.get(args.instrId);
            }
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
                ...yield this.getPerpContext(instr.header),
                { address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY), role: kit_1.AccountRole.READONLY },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            return {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.perpChangeLeverageData)(37, args.instrId, args.leverage),
            };
        });
    }
    /**
     * Build instruction for statistics reset in particular instrument
     * @param args Transaction data
     * @returns Transaction instruction
     */
    perpStatisticsResetInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkClient())) {
                throw new Error("Client account not found");
            }
            let instr = this.instruments.get(args.instrId);
            if (instr.header.perpMapsAddress == undefined) {
                yield this.updateInstrData({ instrId: args.instrId });
                instr = this.instruments.get(args.instrId);
            }
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                { address: this.clientPrimaryAccount, role: kit_1.AccountRole.WRITABLE },
                ...yield this.getPerpContext(instr.header),
                { address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY), role: kit_1.AccountRole.READONLY },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            return {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.perpStatisticsResetData)(46, args.instrId),
            };
        });
    }
    /**
       * Build new instrument instructions
       * @param args New instrument data
       * @returns Transaction instruction
       */
    newInstrumentInstructions(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.signer == null) {
                throw new Error("Wallet is not connected");
            }
            if (args.initialPrice <= 0) {
                throw new Error("Invalid initial price");
            }
            const assetInfo = yield this.rpc.getAccountInfo(args.assetMint).send();
            if (!assetInfo.value) {
                throw new Error("Asset mint not found");
            }
            const tokenProgramId = assetInfo.value.owner == TOKEN_2022_PROGRAM_ID ? TOKEN_2022_PROGRAM_ID : TOKEN_PROGRAM_ID;
            const crncyTokenId = yield this.getTokenId(args.crncyMint);
            const id = yield this.getTokenId(args.assetMint);
            const newAssetToken = id == null;
            const assetTokenId = newAssetToken ? this.rootStateModel.tokensCount : id;
            if (!crncyTokenId) {
                throw new Error("Currency mint not found");
            }
            const mapsAccountSeed = this.version.toString() + "_" +
                types_1.AccountType.SPOT_MAPS.toString() + "_" +
                assetTokenId.toString() + "_" +
                crncyTokenId.toString();
            const mapsAccount = yield (0, kit_1.createAddressWithSeed)({
                baseAddress: this.signer,
                programAddress: this.programId,
                seed: mapsAccountSeed
            });
            const mapsAccountSize = 42184;
            const mapsAccountLamports = yield this.rpc.getMinimumBalanceForRentExemption(BigInt(mapsAccountSize)).send();
            const createMapsAccountIx = (0, system_1.getCreateAccountWithSeedInstruction)({
                payer: this.signer,
                baseAccount: this.signer,
                base: this.signer,
                newAccount: mapsAccount,
                seed: mapsAccountSeed,
                space: mapsAccountSize,
                programAddress: this.programId,
                amount: mapsAccountLamports,
            });
            const slot = Number((yield this.rpc.getSlot().send())) - 1;
            const lutAddress = yield getLookupTableAddress(this.drvsAuthority, slot);
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.WRITABLE },
                { address: yield this.getTokenAccount(args.assetMint), role: newAssetToken ? kit_1.AccountRole.WRITABLE : kit_1.AccountRole.READONLY },
                { address: yield this.getTokenAccount(args.crncyMint), role: kit_1.AccountRole.READONLY },
                { address: newAssetToken ? args.newProgramAccountAddress : this.tokens.get(assetTokenId).programAddress, role: newAssetToken ? kit_1.AccountRole.WRITABLE_SIGNER : kit_1.AccountRole.READONLY },
                { address: args.assetMint, role: kit_1.AccountRole.READONLY },
                { address: lutAddress, role: kit_1.AccountRole.WRITABLE },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
                { address: tokenProgramId, role: kit_1.AccountRole.READONLY },
                { address: ADDRESS_LOOKUP_TABLE_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
                { address: this.drvsAuthority, role: kit_1.AccountRole.READONLY },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: assetTokenId,
                        crncyTokenId: crncyTokenId,
                        tag: types_1.AccountType.INSTR
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: assetTokenId,
                        crncyTokenId: crncyTokenId,
                        tag: types_1.AccountType.SPOT_BIDS_TREE
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: assetTokenId,
                        crncyTokenId: crncyTokenId,
                        tag: types_1.AccountType.SPOT_ASKS_TREE
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: assetTokenId,
                        crncyTokenId: crncyTokenId,
                        tag: types_1.AccountType.SPOT_BID_ORDERS
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: assetTokenId,
                        crncyTokenId: crncyTokenId,
                        tag: types_1.AccountType.SPOT_ASK_ORDERS
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: assetTokenId,
                        crncyTokenId: crncyTokenId,
                        tag: types_1.AccountType.SPOT_LINES
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: mapsAccount, role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: assetTokenId,
                        crncyTokenId: crncyTokenId,
                        tag: types_1.AccountType.SPOT_CLIENT_INFOS
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: assetTokenId,
                        crncyTokenId: crncyTokenId,
                        tag: types_1.AccountType.SPOT_CLIENT_INFOS2
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: assetTokenId,
                        crncyTokenId: crncyTokenId,
                        tag: types_1.AccountType.SPOT_1M_CANDLES
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: assetTokenId,
                        crncyTokenId: crncyTokenId,
                        tag: types_1.AccountType.SPOT_15M_CANDLES
                    }), role: kit_1.AccountRole.WRITABLE
                },
                {
                    address: yield this.getInstrAccountByTag({
                        assetTokenId: assetTokenId,
                        crncyTokenId: crncyTokenId,
                        tag: types_1.AccountType.SPOT_DAY_CANDLES
                    }), role: kit_1.AccountRole.WRITABLE
                },
            ];
            const newInstrIx = {
                accounts: keys,
                programAddress: this.programId,
                data: (0, instruction_models_1.newInstrumentData)(9, crncyTokenId, slot, args.initialPrice * 1000000000)
            };
            return [createMapsAccountIx, newInstrIx];
        });
    }
    /**
     * Build instruction for durect swap
     * @param args Order data
     * @returns Transaction instruction
     */
    swapInstruction(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const assetTokenId = yield this.getTokenId(args.assetMint);
            const crncyTokenId = yield this.getTokenId(args.crncyMint);
            const assetTokenAccount = this.tokens.get(assetTokenId);
            const crncyTokenAccount = this.tokens.get(crncyTokenId);
            const assetTokenProgramId = (assetTokenAccount.mask & 0x80000000) == 0 ?
                TOKEN_PROGRAM_ID : TOKEN_2022_PROGRAM_ID;
            const crncyTokenProgramId = (crncyTokenAccount.mask & 0x80000000) == 0 ?
                TOKEN_PROGRAM_ID : TOKEN_2022_PROGRAM_ID;
            let instrId = yield this.getInstrId({
                assetTokenId: assetTokenId,
                crncyTokenId: crncyTokenId
            });
            const clientAssetTokenAccount = yield findAssociatedTokenAddress(this.signer, assetTokenProgramId, args.assetMint);
            const clientCrncyTokenAccount = yield findAssociatedTokenAddress(this.signer, crncyTokenProgramId, args.crncyMint);
            let instr = this.instruments.get(instrId);
            if (instr.header.mapsAddress == undefined) {
                yield this.updateInstrData({ instrId: instrId });
                instr = this.instruments.get(instrId);
            }
            let buf = (0, instruction_models_1.swapData)(26, args.crncyInput ? 1 : 0, instrId, Math.round(args.limitPrice * 1000000000), Math.round(args.amount *
                (args.crncyInput ?
                    this.tokenDec(instr.header.crncyTokenId) :
                    this.tokenDec(instr.header.assetTokenId))));
            let keys = [
                { address: this.signer, role: kit_1.AccountRole.READONLY_SIGNER },
                { address: this.rootAccount, role: kit_1.AccountRole.READONLY },
                ...yield this.getSpotContext(instr.header),
                ...yield this.getSpotCandles(instr.header),
                {
                    address: yield this.getAccountByTag(types_1.AccountType.COMMUNITY),
                    role: kit_1.AccountRole.READONLY
                },
                { address: assetTokenAccount.programAddress, role: kit_1.AccountRole.WRITABLE },
                { address: crncyTokenAccount.programAddress, role: kit_1.AccountRole.WRITABLE },
                { address: args.assetMint, role: kit_1.AccountRole.READONLY },
                { address: args.crncyMint, role: kit_1.AccountRole.READONLY },
                { address: yield this.getTokenAccount(args.assetMint), role: kit_1.AccountRole.READONLY },
                { address: yield this.getTokenAccount(args.crncyMint), role: kit_1.AccountRole.READONLY },
                { address: clientAssetTokenAccount, role: kit_1.AccountRole.WRITABLE },
                { address: clientCrncyTokenAccount, role: kit_1.AccountRole.WRITABLE },
                { address: this.drvsAuthority, role: kit_1.AccountRole.READONLY },
                { address: SYSTEM_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
                { address: assetTokenProgramId, role: kit_1.AccountRole.READONLY },
                { address: crncyTokenProgramId, role: kit_1.AccountRole.READONLY },
                { address: ASSOCIATED_TOKEN_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
            ];
            return {
                accounts: keys, programAddress: this.programId, data: buf
            };
        });
    }
}
exports.Engine = Engine;
